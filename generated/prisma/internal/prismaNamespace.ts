
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models.js"
import { type PrismaClient } from "./class.js"

export type * from '../models.js'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.3.0
 * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
 */
export const prismaVersion: PrismaVersion = {
  client: "7.3.0",
  engine: "9d6ad21cbbceab97458517b147a6a09ff43aa735"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  User: 'User',
  HomePage: 'HomePage',
  HomePageId: 'HomePageId',
  HomePageEn: 'HomePageEn',
  HeroSlide: 'HeroSlide',
  AboutUsPage: 'AboutUsPage',
  AboutUsPageId: 'AboutUsPageId',
  AboutUsPageEn: 'AboutUsPageEn',
  Governance: 'Governance',
  CompanyStructure: 'CompanyStructure',
  NewsPage: 'NewsPage',
  NewsPageEn: 'NewsPageEn',
  NewsPageId: 'NewsPageId',
  ServicePage: 'ServicePage',
  ServicePageId: 'ServicePageId',
  ServicePageEn: 'ServicePageEn',
  Service: 'Service',
  ServiceId: 'ServiceId',
  ServiceEn: 'ServiceEn',
  CarGallery: 'CarGallery',
  CarGalleryId: 'CarGalleryId',
  CarGalleryEn: 'CarGalleryEn',
  Partner: 'Partner',
  NewsNews: 'NewsNews',
  NewsNewsId: 'NewsNewsId',
  NewsNewsEn: 'NewsNewsEn',
  NewsCSR: 'NewsCSR',
  NewsCSRImage: 'NewsCSRImage',
  NewsCSRId: 'NewsCSRId',
  NewsCSREn: 'NewsCSREn',
  InvestorPage: 'InvestorPage',
  InvestorPageId: 'InvestorPageId',
  InvestorPageEn: 'InvestorPageEn',
  Shares: 'Shares',
  Report: 'Report',
  ReportCategory: 'ReportCategory',
  Metadata: 'Metadata'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "user" | "homePage" | "homePageId" | "homePageEn" | "heroSlide" | "aboutUsPage" | "aboutUsPageId" | "aboutUsPageEn" | "governance" | "companyStructure" | "newsPage" | "newsPageEn" | "newsPageId" | "servicePage" | "servicePageId" | "servicePageEn" | "service" | "serviceId" | "serviceEn" | "carGallery" | "carGalleryId" | "carGalleryEn" | "partner" | "newsNews" | "newsNewsId" | "newsNewsEn" | "newsCSR" | "newsCSRImage" | "newsCSRId" | "newsCSREn" | "investorPage" | "investorPageId" | "investorPageEn" | "shares" | "report" | "reportCategory" | "metadata"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    User: {
      payload: Prisma.$UserPayload<ExtArgs>
      fields: Prisma.UserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>
        }
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number
        }
      }
    }
    HomePage: {
      payload: Prisma.$HomePagePayload<ExtArgs>
      fields: Prisma.HomePageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.HomePageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.HomePageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePagePayload>
        }
        findFirst: {
          args: Prisma.HomePageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.HomePageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePagePayload>
        }
        findMany: {
          args: Prisma.HomePageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePagePayload>[]
        }
        create: {
          args: Prisma.HomePageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePagePayload>
        }
        createMany: {
          args: Prisma.HomePageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.HomePageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePagePayload>[]
        }
        delete: {
          args: Prisma.HomePageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePagePayload>
        }
        update: {
          args: Prisma.HomePageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePagePayload>
        }
        deleteMany: {
          args: Prisma.HomePageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.HomePageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.HomePageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePagePayload>[]
        }
        upsert: {
          args: Prisma.HomePageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePagePayload>
        }
        aggregate: {
          args: Prisma.HomePageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateHomePage>
        }
        groupBy: {
          args: Prisma.HomePageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.HomePageGroupByOutputType>[]
        }
        count: {
          args: Prisma.HomePageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.HomePageCountAggregateOutputType> | number
        }
      }
    }
    HomePageId: {
      payload: Prisma.$HomePageIdPayload<ExtArgs>
      fields: Prisma.HomePageIdFieldRefs
      operations: {
        findUnique: {
          args: Prisma.HomePageIdFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePageIdPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.HomePageIdFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePageIdPayload>
        }
        findFirst: {
          args: Prisma.HomePageIdFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePageIdPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.HomePageIdFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePageIdPayload>
        }
        findMany: {
          args: Prisma.HomePageIdFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePageIdPayload>[]
        }
        create: {
          args: Prisma.HomePageIdCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePageIdPayload>
        }
        createMany: {
          args: Prisma.HomePageIdCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.HomePageIdCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePageIdPayload>[]
        }
        delete: {
          args: Prisma.HomePageIdDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePageIdPayload>
        }
        update: {
          args: Prisma.HomePageIdUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePageIdPayload>
        }
        deleteMany: {
          args: Prisma.HomePageIdDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.HomePageIdUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.HomePageIdUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePageIdPayload>[]
        }
        upsert: {
          args: Prisma.HomePageIdUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePageIdPayload>
        }
        aggregate: {
          args: Prisma.HomePageIdAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateHomePageId>
        }
        groupBy: {
          args: Prisma.HomePageIdGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.HomePageIdGroupByOutputType>[]
        }
        count: {
          args: Prisma.HomePageIdCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.HomePageIdCountAggregateOutputType> | number
        }
      }
    }
    HomePageEn: {
      payload: Prisma.$HomePageEnPayload<ExtArgs>
      fields: Prisma.HomePageEnFieldRefs
      operations: {
        findUnique: {
          args: Prisma.HomePageEnFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePageEnPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.HomePageEnFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePageEnPayload>
        }
        findFirst: {
          args: Prisma.HomePageEnFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePageEnPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.HomePageEnFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePageEnPayload>
        }
        findMany: {
          args: Prisma.HomePageEnFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePageEnPayload>[]
        }
        create: {
          args: Prisma.HomePageEnCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePageEnPayload>
        }
        createMany: {
          args: Prisma.HomePageEnCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.HomePageEnCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePageEnPayload>[]
        }
        delete: {
          args: Prisma.HomePageEnDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePageEnPayload>
        }
        update: {
          args: Prisma.HomePageEnUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePageEnPayload>
        }
        deleteMany: {
          args: Prisma.HomePageEnDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.HomePageEnUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.HomePageEnUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePageEnPayload>[]
        }
        upsert: {
          args: Prisma.HomePageEnUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HomePageEnPayload>
        }
        aggregate: {
          args: Prisma.HomePageEnAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateHomePageEn>
        }
        groupBy: {
          args: Prisma.HomePageEnGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.HomePageEnGroupByOutputType>[]
        }
        count: {
          args: Prisma.HomePageEnCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.HomePageEnCountAggregateOutputType> | number
        }
      }
    }
    HeroSlide: {
      payload: Prisma.$HeroSlidePayload<ExtArgs>
      fields: Prisma.HeroSlideFieldRefs
      operations: {
        findUnique: {
          args: Prisma.HeroSlideFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HeroSlidePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.HeroSlideFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HeroSlidePayload>
        }
        findFirst: {
          args: Prisma.HeroSlideFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HeroSlidePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.HeroSlideFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HeroSlidePayload>
        }
        findMany: {
          args: Prisma.HeroSlideFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HeroSlidePayload>[]
        }
        create: {
          args: Prisma.HeroSlideCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HeroSlidePayload>
        }
        createMany: {
          args: Prisma.HeroSlideCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.HeroSlideCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HeroSlidePayload>[]
        }
        delete: {
          args: Prisma.HeroSlideDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HeroSlidePayload>
        }
        update: {
          args: Prisma.HeroSlideUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HeroSlidePayload>
        }
        deleteMany: {
          args: Prisma.HeroSlideDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.HeroSlideUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.HeroSlideUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HeroSlidePayload>[]
        }
        upsert: {
          args: Prisma.HeroSlideUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HeroSlidePayload>
        }
        aggregate: {
          args: Prisma.HeroSlideAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateHeroSlide>
        }
        groupBy: {
          args: Prisma.HeroSlideGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.HeroSlideGroupByOutputType>[]
        }
        count: {
          args: Prisma.HeroSlideCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.HeroSlideCountAggregateOutputType> | number
        }
      }
    }
    AboutUsPage: {
      payload: Prisma.$AboutUsPagePayload<ExtArgs>
      fields: Prisma.AboutUsPageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AboutUsPageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AboutUsPageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPagePayload>
        }
        findFirst: {
          args: Prisma.AboutUsPageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AboutUsPageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPagePayload>
        }
        findMany: {
          args: Prisma.AboutUsPageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPagePayload>[]
        }
        create: {
          args: Prisma.AboutUsPageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPagePayload>
        }
        createMany: {
          args: Prisma.AboutUsPageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AboutUsPageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPagePayload>[]
        }
        delete: {
          args: Prisma.AboutUsPageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPagePayload>
        }
        update: {
          args: Prisma.AboutUsPageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPagePayload>
        }
        deleteMany: {
          args: Prisma.AboutUsPageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AboutUsPageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AboutUsPageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPagePayload>[]
        }
        upsert: {
          args: Prisma.AboutUsPageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPagePayload>
        }
        aggregate: {
          args: Prisma.AboutUsPageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAboutUsPage>
        }
        groupBy: {
          args: Prisma.AboutUsPageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AboutUsPageGroupByOutputType>[]
        }
        count: {
          args: Prisma.AboutUsPageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AboutUsPageCountAggregateOutputType> | number
        }
      }
    }
    AboutUsPageId: {
      payload: Prisma.$AboutUsPageIdPayload<ExtArgs>
      fields: Prisma.AboutUsPageIdFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AboutUsPageIdFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPageIdPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AboutUsPageIdFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPageIdPayload>
        }
        findFirst: {
          args: Prisma.AboutUsPageIdFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPageIdPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AboutUsPageIdFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPageIdPayload>
        }
        findMany: {
          args: Prisma.AboutUsPageIdFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPageIdPayload>[]
        }
        create: {
          args: Prisma.AboutUsPageIdCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPageIdPayload>
        }
        createMany: {
          args: Prisma.AboutUsPageIdCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AboutUsPageIdCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPageIdPayload>[]
        }
        delete: {
          args: Prisma.AboutUsPageIdDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPageIdPayload>
        }
        update: {
          args: Prisma.AboutUsPageIdUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPageIdPayload>
        }
        deleteMany: {
          args: Prisma.AboutUsPageIdDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AboutUsPageIdUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AboutUsPageIdUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPageIdPayload>[]
        }
        upsert: {
          args: Prisma.AboutUsPageIdUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPageIdPayload>
        }
        aggregate: {
          args: Prisma.AboutUsPageIdAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAboutUsPageId>
        }
        groupBy: {
          args: Prisma.AboutUsPageIdGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AboutUsPageIdGroupByOutputType>[]
        }
        count: {
          args: Prisma.AboutUsPageIdCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AboutUsPageIdCountAggregateOutputType> | number
        }
      }
    }
    AboutUsPageEn: {
      payload: Prisma.$AboutUsPageEnPayload<ExtArgs>
      fields: Prisma.AboutUsPageEnFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AboutUsPageEnFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPageEnPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AboutUsPageEnFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPageEnPayload>
        }
        findFirst: {
          args: Prisma.AboutUsPageEnFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPageEnPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AboutUsPageEnFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPageEnPayload>
        }
        findMany: {
          args: Prisma.AboutUsPageEnFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPageEnPayload>[]
        }
        create: {
          args: Prisma.AboutUsPageEnCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPageEnPayload>
        }
        createMany: {
          args: Prisma.AboutUsPageEnCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AboutUsPageEnCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPageEnPayload>[]
        }
        delete: {
          args: Prisma.AboutUsPageEnDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPageEnPayload>
        }
        update: {
          args: Prisma.AboutUsPageEnUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPageEnPayload>
        }
        deleteMany: {
          args: Prisma.AboutUsPageEnDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AboutUsPageEnUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AboutUsPageEnUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPageEnPayload>[]
        }
        upsert: {
          args: Prisma.AboutUsPageEnUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutUsPageEnPayload>
        }
        aggregate: {
          args: Prisma.AboutUsPageEnAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAboutUsPageEn>
        }
        groupBy: {
          args: Prisma.AboutUsPageEnGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AboutUsPageEnGroupByOutputType>[]
        }
        count: {
          args: Prisma.AboutUsPageEnCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AboutUsPageEnCountAggregateOutputType> | number
        }
      }
    }
    Governance: {
      payload: Prisma.$GovernancePayload<ExtArgs>
      fields: Prisma.GovernanceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GovernanceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GovernancePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GovernanceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GovernancePayload>
        }
        findFirst: {
          args: Prisma.GovernanceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GovernancePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GovernanceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GovernancePayload>
        }
        findMany: {
          args: Prisma.GovernanceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GovernancePayload>[]
        }
        create: {
          args: Prisma.GovernanceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GovernancePayload>
        }
        createMany: {
          args: Prisma.GovernanceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GovernanceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GovernancePayload>[]
        }
        delete: {
          args: Prisma.GovernanceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GovernancePayload>
        }
        update: {
          args: Prisma.GovernanceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GovernancePayload>
        }
        deleteMany: {
          args: Prisma.GovernanceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GovernanceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GovernanceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GovernancePayload>[]
        }
        upsert: {
          args: Prisma.GovernanceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GovernancePayload>
        }
        aggregate: {
          args: Prisma.GovernanceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGovernance>
        }
        groupBy: {
          args: Prisma.GovernanceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GovernanceGroupByOutputType>[]
        }
        count: {
          args: Prisma.GovernanceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GovernanceCountAggregateOutputType> | number
        }
      }
    }
    CompanyStructure: {
      payload: Prisma.$CompanyStructurePayload<ExtArgs>
      fields: Prisma.CompanyStructureFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CompanyStructureFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyStructurePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CompanyStructureFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyStructurePayload>
        }
        findFirst: {
          args: Prisma.CompanyStructureFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyStructurePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CompanyStructureFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyStructurePayload>
        }
        findMany: {
          args: Prisma.CompanyStructureFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyStructurePayload>[]
        }
        create: {
          args: Prisma.CompanyStructureCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyStructurePayload>
        }
        createMany: {
          args: Prisma.CompanyStructureCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CompanyStructureCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyStructurePayload>[]
        }
        delete: {
          args: Prisma.CompanyStructureDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyStructurePayload>
        }
        update: {
          args: Prisma.CompanyStructureUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyStructurePayload>
        }
        deleteMany: {
          args: Prisma.CompanyStructureDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CompanyStructureUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CompanyStructureUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyStructurePayload>[]
        }
        upsert: {
          args: Prisma.CompanyStructureUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyStructurePayload>
        }
        aggregate: {
          args: Prisma.CompanyStructureAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCompanyStructure>
        }
        groupBy: {
          args: Prisma.CompanyStructureGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyStructureGroupByOutputType>[]
        }
        count: {
          args: Prisma.CompanyStructureCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyStructureCountAggregateOutputType> | number
        }
      }
    }
    NewsPage: {
      payload: Prisma.$NewsPagePayload<ExtArgs>
      fields: Prisma.NewsPageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NewsPageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NewsPageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPagePayload>
        }
        findFirst: {
          args: Prisma.NewsPageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NewsPageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPagePayload>
        }
        findMany: {
          args: Prisma.NewsPageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPagePayload>[]
        }
        create: {
          args: Prisma.NewsPageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPagePayload>
        }
        createMany: {
          args: Prisma.NewsPageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NewsPageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPagePayload>[]
        }
        delete: {
          args: Prisma.NewsPageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPagePayload>
        }
        update: {
          args: Prisma.NewsPageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPagePayload>
        }
        deleteMany: {
          args: Prisma.NewsPageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NewsPageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NewsPageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPagePayload>[]
        }
        upsert: {
          args: Prisma.NewsPageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPagePayload>
        }
        aggregate: {
          args: Prisma.NewsPageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNewsPage>
        }
        groupBy: {
          args: Prisma.NewsPageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewsPageGroupByOutputType>[]
        }
        count: {
          args: Prisma.NewsPageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewsPageCountAggregateOutputType> | number
        }
      }
    }
    NewsPageEn: {
      payload: Prisma.$NewsPageEnPayload<ExtArgs>
      fields: Prisma.NewsPageEnFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NewsPageEnFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPageEnPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NewsPageEnFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPageEnPayload>
        }
        findFirst: {
          args: Prisma.NewsPageEnFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPageEnPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NewsPageEnFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPageEnPayload>
        }
        findMany: {
          args: Prisma.NewsPageEnFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPageEnPayload>[]
        }
        create: {
          args: Prisma.NewsPageEnCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPageEnPayload>
        }
        createMany: {
          args: Prisma.NewsPageEnCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NewsPageEnCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPageEnPayload>[]
        }
        delete: {
          args: Prisma.NewsPageEnDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPageEnPayload>
        }
        update: {
          args: Prisma.NewsPageEnUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPageEnPayload>
        }
        deleteMany: {
          args: Prisma.NewsPageEnDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NewsPageEnUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NewsPageEnUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPageEnPayload>[]
        }
        upsert: {
          args: Prisma.NewsPageEnUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPageEnPayload>
        }
        aggregate: {
          args: Prisma.NewsPageEnAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNewsPageEn>
        }
        groupBy: {
          args: Prisma.NewsPageEnGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewsPageEnGroupByOutputType>[]
        }
        count: {
          args: Prisma.NewsPageEnCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewsPageEnCountAggregateOutputType> | number
        }
      }
    }
    NewsPageId: {
      payload: Prisma.$NewsPageIdPayload<ExtArgs>
      fields: Prisma.NewsPageIdFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NewsPageIdFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPageIdPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NewsPageIdFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPageIdPayload>
        }
        findFirst: {
          args: Prisma.NewsPageIdFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPageIdPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NewsPageIdFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPageIdPayload>
        }
        findMany: {
          args: Prisma.NewsPageIdFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPageIdPayload>[]
        }
        create: {
          args: Prisma.NewsPageIdCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPageIdPayload>
        }
        createMany: {
          args: Prisma.NewsPageIdCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NewsPageIdCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPageIdPayload>[]
        }
        delete: {
          args: Prisma.NewsPageIdDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPageIdPayload>
        }
        update: {
          args: Prisma.NewsPageIdUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPageIdPayload>
        }
        deleteMany: {
          args: Prisma.NewsPageIdDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NewsPageIdUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NewsPageIdUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPageIdPayload>[]
        }
        upsert: {
          args: Prisma.NewsPageIdUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsPageIdPayload>
        }
        aggregate: {
          args: Prisma.NewsPageIdAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNewsPageId>
        }
        groupBy: {
          args: Prisma.NewsPageIdGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewsPageIdGroupByOutputType>[]
        }
        count: {
          args: Prisma.NewsPageIdCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewsPageIdCountAggregateOutputType> | number
        }
      }
    }
    ServicePage: {
      payload: Prisma.$ServicePagePayload<ExtArgs>
      fields: Prisma.ServicePageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ServicePageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ServicePageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePagePayload>
        }
        findFirst: {
          args: Prisma.ServicePageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ServicePageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePagePayload>
        }
        findMany: {
          args: Prisma.ServicePageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePagePayload>[]
        }
        create: {
          args: Prisma.ServicePageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePagePayload>
        }
        createMany: {
          args: Prisma.ServicePageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ServicePageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePagePayload>[]
        }
        delete: {
          args: Prisma.ServicePageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePagePayload>
        }
        update: {
          args: Prisma.ServicePageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePagePayload>
        }
        deleteMany: {
          args: Prisma.ServicePageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ServicePageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ServicePageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePagePayload>[]
        }
        upsert: {
          args: Prisma.ServicePageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePagePayload>
        }
        aggregate: {
          args: Prisma.ServicePageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateServicePage>
        }
        groupBy: {
          args: Prisma.ServicePageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServicePageGroupByOutputType>[]
        }
        count: {
          args: Prisma.ServicePageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServicePageCountAggregateOutputType> | number
        }
      }
    }
    ServicePageId: {
      payload: Prisma.$ServicePageIdPayload<ExtArgs>
      fields: Prisma.ServicePageIdFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ServicePageIdFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePageIdPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ServicePageIdFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePageIdPayload>
        }
        findFirst: {
          args: Prisma.ServicePageIdFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePageIdPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ServicePageIdFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePageIdPayload>
        }
        findMany: {
          args: Prisma.ServicePageIdFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePageIdPayload>[]
        }
        create: {
          args: Prisma.ServicePageIdCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePageIdPayload>
        }
        createMany: {
          args: Prisma.ServicePageIdCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ServicePageIdCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePageIdPayload>[]
        }
        delete: {
          args: Prisma.ServicePageIdDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePageIdPayload>
        }
        update: {
          args: Prisma.ServicePageIdUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePageIdPayload>
        }
        deleteMany: {
          args: Prisma.ServicePageIdDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ServicePageIdUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ServicePageIdUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePageIdPayload>[]
        }
        upsert: {
          args: Prisma.ServicePageIdUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePageIdPayload>
        }
        aggregate: {
          args: Prisma.ServicePageIdAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateServicePageId>
        }
        groupBy: {
          args: Prisma.ServicePageIdGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServicePageIdGroupByOutputType>[]
        }
        count: {
          args: Prisma.ServicePageIdCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServicePageIdCountAggregateOutputType> | number
        }
      }
    }
    ServicePageEn: {
      payload: Prisma.$ServicePageEnPayload<ExtArgs>
      fields: Prisma.ServicePageEnFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ServicePageEnFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePageEnPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ServicePageEnFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePageEnPayload>
        }
        findFirst: {
          args: Prisma.ServicePageEnFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePageEnPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ServicePageEnFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePageEnPayload>
        }
        findMany: {
          args: Prisma.ServicePageEnFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePageEnPayload>[]
        }
        create: {
          args: Prisma.ServicePageEnCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePageEnPayload>
        }
        createMany: {
          args: Prisma.ServicePageEnCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ServicePageEnCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePageEnPayload>[]
        }
        delete: {
          args: Prisma.ServicePageEnDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePageEnPayload>
        }
        update: {
          args: Prisma.ServicePageEnUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePageEnPayload>
        }
        deleteMany: {
          args: Prisma.ServicePageEnDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ServicePageEnUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ServicePageEnUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePageEnPayload>[]
        }
        upsert: {
          args: Prisma.ServicePageEnUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePageEnPayload>
        }
        aggregate: {
          args: Prisma.ServicePageEnAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateServicePageEn>
        }
        groupBy: {
          args: Prisma.ServicePageEnGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServicePageEnGroupByOutputType>[]
        }
        count: {
          args: Prisma.ServicePageEnCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServicePageEnCountAggregateOutputType> | number
        }
      }
    }
    Service: {
      payload: Prisma.$ServicePayload<ExtArgs>
      fields: Prisma.ServiceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ServiceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        findFirst: {
          args: Prisma.ServiceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        findMany: {
          args: Prisma.ServiceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>[]
        }
        create: {
          args: Prisma.ServiceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        createMany: {
          args: Prisma.ServiceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>[]
        }
        delete: {
          args: Prisma.ServiceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        update: {
          args: Prisma.ServiceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        deleteMany: {
          args: Prisma.ServiceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ServiceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>[]
        }
        upsert: {
          args: Prisma.ServiceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        aggregate: {
          args: Prisma.ServiceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateService>
        }
        groupBy: {
          args: Prisma.ServiceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServiceGroupByOutputType>[]
        }
        count: {
          args: Prisma.ServiceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServiceCountAggregateOutputType> | number
        }
      }
    }
    ServiceId: {
      payload: Prisma.$ServiceIdPayload<ExtArgs>
      fields: Prisma.ServiceIdFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ServiceIdFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceIdPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ServiceIdFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceIdPayload>
        }
        findFirst: {
          args: Prisma.ServiceIdFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceIdPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ServiceIdFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceIdPayload>
        }
        findMany: {
          args: Prisma.ServiceIdFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceIdPayload>[]
        }
        create: {
          args: Prisma.ServiceIdCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceIdPayload>
        }
        createMany: {
          args: Prisma.ServiceIdCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ServiceIdCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceIdPayload>[]
        }
        delete: {
          args: Prisma.ServiceIdDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceIdPayload>
        }
        update: {
          args: Prisma.ServiceIdUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceIdPayload>
        }
        deleteMany: {
          args: Prisma.ServiceIdDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ServiceIdUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ServiceIdUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceIdPayload>[]
        }
        upsert: {
          args: Prisma.ServiceIdUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceIdPayload>
        }
        aggregate: {
          args: Prisma.ServiceIdAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateServiceId>
        }
        groupBy: {
          args: Prisma.ServiceIdGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServiceIdGroupByOutputType>[]
        }
        count: {
          args: Prisma.ServiceIdCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServiceIdCountAggregateOutputType> | number
        }
      }
    }
    ServiceEn: {
      payload: Prisma.$ServiceEnPayload<ExtArgs>
      fields: Prisma.ServiceEnFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ServiceEnFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceEnPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ServiceEnFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceEnPayload>
        }
        findFirst: {
          args: Prisma.ServiceEnFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceEnPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ServiceEnFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceEnPayload>
        }
        findMany: {
          args: Prisma.ServiceEnFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceEnPayload>[]
        }
        create: {
          args: Prisma.ServiceEnCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceEnPayload>
        }
        createMany: {
          args: Prisma.ServiceEnCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ServiceEnCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceEnPayload>[]
        }
        delete: {
          args: Prisma.ServiceEnDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceEnPayload>
        }
        update: {
          args: Prisma.ServiceEnUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceEnPayload>
        }
        deleteMany: {
          args: Prisma.ServiceEnDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ServiceEnUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ServiceEnUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceEnPayload>[]
        }
        upsert: {
          args: Prisma.ServiceEnUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceEnPayload>
        }
        aggregate: {
          args: Prisma.ServiceEnAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateServiceEn>
        }
        groupBy: {
          args: Prisma.ServiceEnGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServiceEnGroupByOutputType>[]
        }
        count: {
          args: Prisma.ServiceEnCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServiceEnCountAggregateOutputType> | number
        }
      }
    }
    CarGallery: {
      payload: Prisma.$CarGalleryPayload<ExtArgs>
      fields: Prisma.CarGalleryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CarGalleryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CarGalleryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryPayload>
        }
        findFirst: {
          args: Prisma.CarGalleryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CarGalleryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryPayload>
        }
        findMany: {
          args: Prisma.CarGalleryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryPayload>[]
        }
        create: {
          args: Prisma.CarGalleryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryPayload>
        }
        createMany: {
          args: Prisma.CarGalleryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CarGalleryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryPayload>[]
        }
        delete: {
          args: Prisma.CarGalleryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryPayload>
        }
        update: {
          args: Prisma.CarGalleryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryPayload>
        }
        deleteMany: {
          args: Prisma.CarGalleryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CarGalleryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CarGalleryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryPayload>[]
        }
        upsert: {
          args: Prisma.CarGalleryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryPayload>
        }
        aggregate: {
          args: Prisma.CarGalleryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCarGallery>
        }
        groupBy: {
          args: Prisma.CarGalleryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CarGalleryGroupByOutputType>[]
        }
        count: {
          args: Prisma.CarGalleryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CarGalleryCountAggregateOutputType> | number
        }
      }
    }
    CarGalleryId: {
      payload: Prisma.$CarGalleryIdPayload<ExtArgs>
      fields: Prisma.CarGalleryIdFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CarGalleryIdFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryIdPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CarGalleryIdFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryIdPayload>
        }
        findFirst: {
          args: Prisma.CarGalleryIdFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryIdPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CarGalleryIdFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryIdPayload>
        }
        findMany: {
          args: Prisma.CarGalleryIdFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryIdPayload>[]
        }
        create: {
          args: Prisma.CarGalleryIdCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryIdPayload>
        }
        createMany: {
          args: Prisma.CarGalleryIdCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CarGalleryIdCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryIdPayload>[]
        }
        delete: {
          args: Prisma.CarGalleryIdDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryIdPayload>
        }
        update: {
          args: Prisma.CarGalleryIdUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryIdPayload>
        }
        deleteMany: {
          args: Prisma.CarGalleryIdDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CarGalleryIdUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CarGalleryIdUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryIdPayload>[]
        }
        upsert: {
          args: Prisma.CarGalleryIdUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryIdPayload>
        }
        aggregate: {
          args: Prisma.CarGalleryIdAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCarGalleryId>
        }
        groupBy: {
          args: Prisma.CarGalleryIdGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CarGalleryIdGroupByOutputType>[]
        }
        count: {
          args: Prisma.CarGalleryIdCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CarGalleryIdCountAggregateOutputType> | number
        }
      }
    }
    CarGalleryEn: {
      payload: Prisma.$CarGalleryEnPayload<ExtArgs>
      fields: Prisma.CarGalleryEnFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CarGalleryEnFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryEnPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CarGalleryEnFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryEnPayload>
        }
        findFirst: {
          args: Prisma.CarGalleryEnFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryEnPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CarGalleryEnFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryEnPayload>
        }
        findMany: {
          args: Prisma.CarGalleryEnFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryEnPayload>[]
        }
        create: {
          args: Prisma.CarGalleryEnCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryEnPayload>
        }
        createMany: {
          args: Prisma.CarGalleryEnCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CarGalleryEnCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryEnPayload>[]
        }
        delete: {
          args: Prisma.CarGalleryEnDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryEnPayload>
        }
        update: {
          args: Prisma.CarGalleryEnUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryEnPayload>
        }
        deleteMany: {
          args: Prisma.CarGalleryEnDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CarGalleryEnUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CarGalleryEnUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryEnPayload>[]
        }
        upsert: {
          args: Prisma.CarGalleryEnUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarGalleryEnPayload>
        }
        aggregate: {
          args: Prisma.CarGalleryEnAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCarGalleryEn>
        }
        groupBy: {
          args: Prisma.CarGalleryEnGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CarGalleryEnGroupByOutputType>[]
        }
        count: {
          args: Prisma.CarGalleryEnCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CarGalleryEnCountAggregateOutputType> | number
        }
      }
    }
    Partner: {
      payload: Prisma.$PartnerPayload<ExtArgs>
      fields: Prisma.PartnerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PartnerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PartnerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPayload>
        }
        findFirst: {
          args: Prisma.PartnerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PartnerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPayload>
        }
        findMany: {
          args: Prisma.PartnerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPayload>[]
        }
        create: {
          args: Prisma.PartnerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPayload>
        }
        createMany: {
          args: Prisma.PartnerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PartnerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPayload>[]
        }
        delete: {
          args: Prisma.PartnerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPayload>
        }
        update: {
          args: Prisma.PartnerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPayload>
        }
        deleteMany: {
          args: Prisma.PartnerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PartnerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PartnerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPayload>[]
        }
        upsert: {
          args: Prisma.PartnerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PartnerPayload>
        }
        aggregate: {
          args: Prisma.PartnerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePartner>
        }
        groupBy: {
          args: Prisma.PartnerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PartnerGroupByOutputType>[]
        }
        count: {
          args: Prisma.PartnerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PartnerCountAggregateOutputType> | number
        }
      }
    }
    NewsNews: {
      payload: Prisma.$NewsNewsPayload<ExtArgs>
      fields: Prisma.NewsNewsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NewsNewsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NewsNewsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsPayload>
        }
        findFirst: {
          args: Prisma.NewsNewsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NewsNewsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsPayload>
        }
        findMany: {
          args: Prisma.NewsNewsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsPayload>[]
        }
        create: {
          args: Prisma.NewsNewsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsPayload>
        }
        createMany: {
          args: Prisma.NewsNewsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NewsNewsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsPayload>[]
        }
        delete: {
          args: Prisma.NewsNewsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsPayload>
        }
        update: {
          args: Prisma.NewsNewsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsPayload>
        }
        deleteMany: {
          args: Prisma.NewsNewsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NewsNewsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NewsNewsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsPayload>[]
        }
        upsert: {
          args: Prisma.NewsNewsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsPayload>
        }
        aggregate: {
          args: Prisma.NewsNewsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNewsNews>
        }
        groupBy: {
          args: Prisma.NewsNewsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewsNewsGroupByOutputType>[]
        }
        count: {
          args: Prisma.NewsNewsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewsNewsCountAggregateOutputType> | number
        }
      }
    }
    NewsNewsId: {
      payload: Prisma.$NewsNewsIdPayload<ExtArgs>
      fields: Prisma.NewsNewsIdFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NewsNewsIdFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsIdPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NewsNewsIdFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsIdPayload>
        }
        findFirst: {
          args: Prisma.NewsNewsIdFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsIdPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NewsNewsIdFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsIdPayload>
        }
        findMany: {
          args: Prisma.NewsNewsIdFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsIdPayload>[]
        }
        create: {
          args: Prisma.NewsNewsIdCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsIdPayload>
        }
        createMany: {
          args: Prisma.NewsNewsIdCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NewsNewsIdCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsIdPayload>[]
        }
        delete: {
          args: Prisma.NewsNewsIdDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsIdPayload>
        }
        update: {
          args: Prisma.NewsNewsIdUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsIdPayload>
        }
        deleteMany: {
          args: Prisma.NewsNewsIdDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NewsNewsIdUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NewsNewsIdUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsIdPayload>[]
        }
        upsert: {
          args: Prisma.NewsNewsIdUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsIdPayload>
        }
        aggregate: {
          args: Prisma.NewsNewsIdAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNewsNewsId>
        }
        groupBy: {
          args: Prisma.NewsNewsIdGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewsNewsIdGroupByOutputType>[]
        }
        count: {
          args: Prisma.NewsNewsIdCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewsNewsIdCountAggregateOutputType> | number
        }
      }
    }
    NewsNewsEn: {
      payload: Prisma.$NewsNewsEnPayload<ExtArgs>
      fields: Prisma.NewsNewsEnFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NewsNewsEnFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsEnPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NewsNewsEnFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsEnPayload>
        }
        findFirst: {
          args: Prisma.NewsNewsEnFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsEnPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NewsNewsEnFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsEnPayload>
        }
        findMany: {
          args: Prisma.NewsNewsEnFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsEnPayload>[]
        }
        create: {
          args: Prisma.NewsNewsEnCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsEnPayload>
        }
        createMany: {
          args: Prisma.NewsNewsEnCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NewsNewsEnCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsEnPayload>[]
        }
        delete: {
          args: Prisma.NewsNewsEnDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsEnPayload>
        }
        update: {
          args: Prisma.NewsNewsEnUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsEnPayload>
        }
        deleteMany: {
          args: Prisma.NewsNewsEnDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NewsNewsEnUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NewsNewsEnUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsEnPayload>[]
        }
        upsert: {
          args: Prisma.NewsNewsEnUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsNewsEnPayload>
        }
        aggregate: {
          args: Prisma.NewsNewsEnAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNewsNewsEn>
        }
        groupBy: {
          args: Prisma.NewsNewsEnGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewsNewsEnGroupByOutputType>[]
        }
        count: {
          args: Prisma.NewsNewsEnCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewsNewsEnCountAggregateOutputType> | number
        }
      }
    }
    NewsCSR: {
      payload: Prisma.$NewsCSRPayload<ExtArgs>
      fields: Prisma.NewsCSRFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NewsCSRFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NewsCSRFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRPayload>
        }
        findFirst: {
          args: Prisma.NewsCSRFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NewsCSRFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRPayload>
        }
        findMany: {
          args: Prisma.NewsCSRFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRPayload>[]
        }
        create: {
          args: Prisma.NewsCSRCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRPayload>
        }
        createMany: {
          args: Prisma.NewsCSRCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NewsCSRCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRPayload>[]
        }
        delete: {
          args: Prisma.NewsCSRDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRPayload>
        }
        update: {
          args: Prisma.NewsCSRUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRPayload>
        }
        deleteMany: {
          args: Prisma.NewsCSRDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NewsCSRUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NewsCSRUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRPayload>[]
        }
        upsert: {
          args: Prisma.NewsCSRUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRPayload>
        }
        aggregate: {
          args: Prisma.NewsCSRAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNewsCSR>
        }
        groupBy: {
          args: Prisma.NewsCSRGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewsCSRGroupByOutputType>[]
        }
        count: {
          args: Prisma.NewsCSRCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewsCSRCountAggregateOutputType> | number
        }
      }
    }
    NewsCSRImage: {
      payload: Prisma.$NewsCSRImagePayload<ExtArgs>
      fields: Prisma.NewsCSRImageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NewsCSRImageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRImagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NewsCSRImageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRImagePayload>
        }
        findFirst: {
          args: Prisma.NewsCSRImageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRImagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NewsCSRImageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRImagePayload>
        }
        findMany: {
          args: Prisma.NewsCSRImageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRImagePayload>[]
        }
        create: {
          args: Prisma.NewsCSRImageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRImagePayload>
        }
        createMany: {
          args: Prisma.NewsCSRImageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NewsCSRImageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRImagePayload>[]
        }
        delete: {
          args: Prisma.NewsCSRImageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRImagePayload>
        }
        update: {
          args: Prisma.NewsCSRImageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRImagePayload>
        }
        deleteMany: {
          args: Prisma.NewsCSRImageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NewsCSRImageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NewsCSRImageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRImagePayload>[]
        }
        upsert: {
          args: Prisma.NewsCSRImageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRImagePayload>
        }
        aggregate: {
          args: Prisma.NewsCSRImageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNewsCSRImage>
        }
        groupBy: {
          args: Prisma.NewsCSRImageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewsCSRImageGroupByOutputType>[]
        }
        count: {
          args: Prisma.NewsCSRImageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewsCSRImageCountAggregateOutputType> | number
        }
      }
    }
    NewsCSRId: {
      payload: Prisma.$NewsCSRIdPayload<ExtArgs>
      fields: Prisma.NewsCSRIdFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NewsCSRIdFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRIdPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NewsCSRIdFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRIdPayload>
        }
        findFirst: {
          args: Prisma.NewsCSRIdFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRIdPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NewsCSRIdFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRIdPayload>
        }
        findMany: {
          args: Prisma.NewsCSRIdFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRIdPayload>[]
        }
        create: {
          args: Prisma.NewsCSRIdCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRIdPayload>
        }
        createMany: {
          args: Prisma.NewsCSRIdCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NewsCSRIdCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRIdPayload>[]
        }
        delete: {
          args: Prisma.NewsCSRIdDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRIdPayload>
        }
        update: {
          args: Prisma.NewsCSRIdUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRIdPayload>
        }
        deleteMany: {
          args: Prisma.NewsCSRIdDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NewsCSRIdUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NewsCSRIdUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRIdPayload>[]
        }
        upsert: {
          args: Prisma.NewsCSRIdUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSRIdPayload>
        }
        aggregate: {
          args: Prisma.NewsCSRIdAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNewsCSRId>
        }
        groupBy: {
          args: Prisma.NewsCSRIdGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewsCSRIdGroupByOutputType>[]
        }
        count: {
          args: Prisma.NewsCSRIdCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewsCSRIdCountAggregateOutputType> | number
        }
      }
    }
    NewsCSREn: {
      payload: Prisma.$NewsCSREnPayload<ExtArgs>
      fields: Prisma.NewsCSREnFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NewsCSREnFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSREnPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NewsCSREnFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSREnPayload>
        }
        findFirst: {
          args: Prisma.NewsCSREnFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSREnPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NewsCSREnFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSREnPayload>
        }
        findMany: {
          args: Prisma.NewsCSREnFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSREnPayload>[]
        }
        create: {
          args: Prisma.NewsCSREnCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSREnPayload>
        }
        createMany: {
          args: Prisma.NewsCSREnCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NewsCSREnCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSREnPayload>[]
        }
        delete: {
          args: Prisma.NewsCSREnDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSREnPayload>
        }
        update: {
          args: Prisma.NewsCSREnUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSREnPayload>
        }
        deleteMany: {
          args: Prisma.NewsCSREnDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NewsCSREnUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NewsCSREnUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSREnPayload>[]
        }
        upsert: {
          args: Prisma.NewsCSREnUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewsCSREnPayload>
        }
        aggregate: {
          args: Prisma.NewsCSREnAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNewsCSREn>
        }
        groupBy: {
          args: Prisma.NewsCSREnGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewsCSREnGroupByOutputType>[]
        }
        count: {
          args: Prisma.NewsCSREnCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewsCSREnCountAggregateOutputType> | number
        }
      }
    }
    InvestorPage: {
      payload: Prisma.$InvestorPagePayload<ExtArgs>
      fields: Prisma.InvestorPageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InvestorPageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InvestorPageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPagePayload>
        }
        findFirst: {
          args: Prisma.InvestorPageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InvestorPageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPagePayload>
        }
        findMany: {
          args: Prisma.InvestorPageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPagePayload>[]
        }
        create: {
          args: Prisma.InvestorPageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPagePayload>
        }
        createMany: {
          args: Prisma.InvestorPageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InvestorPageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPagePayload>[]
        }
        delete: {
          args: Prisma.InvestorPageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPagePayload>
        }
        update: {
          args: Prisma.InvestorPageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPagePayload>
        }
        deleteMany: {
          args: Prisma.InvestorPageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InvestorPageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InvestorPageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPagePayload>[]
        }
        upsert: {
          args: Prisma.InvestorPageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPagePayload>
        }
        aggregate: {
          args: Prisma.InvestorPageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInvestorPage>
        }
        groupBy: {
          args: Prisma.InvestorPageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvestorPageGroupByOutputType>[]
        }
        count: {
          args: Prisma.InvestorPageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvestorPageCountAggregateOutputType> | number
        }
      }
    }
    InvestorPageId: {
      payload: Prisma.$InvestorPageIdPayload<ExtArgs>
      fields: Prisma.InvestorPageIdFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InvestorPageIdFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPageIdPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InvestorPageIdFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPageIdPayload>
        }
        findFirst: {
          args: Prisma.InvestorPageIdFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPageIdPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InvestorPageIdFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPageIdPayload>
        }
        findMany: {
          args: Prisma.InvestorPageIdFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPageIdPayload>[]
        }
        create: {
          args: Prisma.InvestorPageIdCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPageIdPayload>
        }
        createMany: {
          args: Prisma.InvestorPageIdCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InvestorPageIdCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPageIdPayload>[]
        }
        delete: {
          args: Prisma.InvestorPageIdDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPageIdPayload>
        }
        update: {
          args: Prisma.InvestorPageIdUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPageIdPayload>
        }
        deleteMany: {
          args: Prisma.InvestorPageIdDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InvestorPageIdUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InvestorPageIdUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPageIdPayload>[]
        }
        upsert: {
          args: Prisma.InvestorPageIdUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPageIdPayload>
        }
        aggregate: {
          args: Prisma.InvestorPageIdAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInvestorPageId>
        }
        groupBy: {
          args: Prisma.InvestorPageIdGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvestorPageIdGroupByOutputType>[]
        }
        count: {
          args: Prisma.InvestorPageIdCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvestorPageIdCountAggregateOutputType> | number
        }
      }
    }
    InvestorPageEn: {
      payload: Prisma.$InvestorPageEnPayload<ExtArgs>
      fields: Prisma.InvestorPageEnFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InvestorPageEnFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPageEnPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InvestorPageEnFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPageEnPayload>
        }
        findFirst: {
          args: Prisma.InvestorPageEnFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPageEnPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InvestorPageEnFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPageEnPayload>
        }
        findMany: {
          args: Prisma.InvestorPageEnFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPageEnPayload>[]
        }
        create: {
          args: Prisma.InvestorPageEnCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPageEnPayload>
        }
        createMany: {
          args: Prisma.InvestorPageEnCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InvestorPageEnCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPageEnPayload>[]
        }
        delete: {
          args: Prisma.InvestorPageEnDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPageEnPayload>
        }
        update: {
          args: Prisma.InvestorPageEnUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPageEnPayload>
        }
        deleteMany: {
          args: Prisma.InvestorPageEnDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InvestorPageEnUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InvestorPageEnUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPageEnPayload>[]
        }
        upsert: {
          args: Prisma.InvestorPageEnUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvestorPageEnPayload>
        }
        aggregate: {
          args: Prisma.InvestorPageEnAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInvestorPageEn>
        }
        groupBy: {
          args: Prisma.InvestorPageEnGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvestorPageEnGroupByOutputType>[]
        }
        count: {
          args: Prisma.InvestorPageEnCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvestorPageEnCountAggregateOutputType> | number
        }
      }
    }
    Shares: {
      payload: Prisma.$SharesPayload<ExtArgs>
      fields: Prisma.SharesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SharesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SharesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SharesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SharesPayload>
        }
        findFirst: {
          args: Prisma.SharesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SharesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SharesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SharesPayload>
        }
        findMany: {
          args: Prisma.SharesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SharesPayload>[]
        }
        create: {
          args: Prisma.SharesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SharesPayload>
        }
        createMany: {
          args: Prisma.SharesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SharesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SharesPayload>[]
        }
        delete: {
          args: Prisma.SharesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SharesPayload>
        }
        update: {
          args: Prisma.SharesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SharesPayload>
        }
        deleteMany: {
          args: Prisma.SharesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SharesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SharesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SharesPayload>[]
        }
        upsert: {
          args: Prisma.SharesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SharesPayload>
        }
        aggregate: {
          args: Prisma.SharesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateShares>
        }
        groupBy: {
          args: Prisma.SharesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SharesGroupByOutputType>[]
        }
        count: {
          args: Prisma.SharesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SharesCountAggregateOutputType> | number
        }
      }
    }
    Report: {
      payload: Prisma.$ReportPayload<ExtArgs>
      fields: Prisma.ReportFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ReportFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>
        }
        findFirst: {
          args: Prisma.ReportFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>
        }
        findMany: {
          args: Prisma.ReportFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>[]
        }
        create: {
          args: Prisma.ReportCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>
        }
        createMany: {
          args: Prisma.ReportCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>[]
        }
        delete: {
          args: Prisma.ReportDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>
        }
        update: {
          args: Prisma.ReportUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>
        }
        deleteMany: {
          args: Prisma.ReportDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ReportUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ReportUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>[]
        }
        upsert: {
          args: Prisma.ReportUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportPayload>
        }
        aggregate: {
          args: Prisma.ReportAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReport>
        }
        groupBy: {
          args: Prisma.ReportGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReportGroupByOutputType>[]
        }
        count: {
          args: Prisma.ReportCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReportCountAggregateOutputType> | number
        }
      }
    }
    ReportCategory: {
      payload: Prisma.$ReportCategoryPayload<ExtArgs>
      fields: Prisma.ReportCategoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ReportCategoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportCategoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ReportCategoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportCategoryPayload>
        }
        findFirst: {
          args: Prisma.ReportCategoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportCategoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ReportCategoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportCategoryPayload>
        }
        findMany: {
          args: Prisma.ReportCategoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportCategoryPayload>[]
        }
        create: {
          args: Prisma.ReportCategoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportCategoryPayload>
        }
        createMany: {
          args: Prisma.ReportCategoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ReportCategoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportCategoryPayload>[]
        }
        delete: {
          args: Prisma.ReportCategoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportCategoryPayload>
        }
        update: {
          args: Prisma.ReportCategoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportCategoryPayload>
        }
        deleteMany: {
          args: Prisma.ReportCategoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ReportCategoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ReportCategoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportCategoryPayload>[]
        }
        upsert: {
          args: Prisma.ReportCategoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReportCategoryPayload>
        }
        aggregate: {
          args: Prisma.ReportCategoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReportCategory>
        }
        groupBy: {
          args: Prisma.ReportCategoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReportCategoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.ReportCategoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReportCategoryCountAggregateOutputType> | number
        }
      }
    }
    Metadata: {
      payload: Prisma.$MetadataPayload<ExtArgs>
      fields: Prisma.MetadataFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MetadataFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MetadataPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MetadataFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MetadataPayload>
        }
        findFirst: {
          args: Prisma.MetadataFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MetadataPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MetadataFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MetadataPayload>
        }
        findMany: {
          args: Prisma.MetadataFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MetadataPayload>[]
        }
        create: {
          args: Prisma.MetadataCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MetadataPayload>
        }
        createMany: {
          args: Prisma.MetadataCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MetadataCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MetadataPayload>[]
        }
        delete: {
          args: Prisma.MetadataDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MetadataPayload>
        }
        update: {
          args: Prisma.MetadataUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MetadataPayload>
        }
        deleteMany: {
          args: Prisma.MetadataDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MetadataUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MetadataUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MetadataPayload>[]
        }
        upsert: {
          args: Prisma.MetadataUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MetadataPayload>
        }
        aggregate: {
          args: Prisma.MetadataAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMetadata>
        }
        groupBy: {
          args: Prisma.MetadataGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MetadataGroupByOutputType>[]
        }
        count: {
          args: Prisma.MetadataCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MetadataCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const UserScalarFieldEnum = {
  id: 'id',
  email: 'email',
  password: 'password',
  name: 'name',
  role: 'role',
  profile_image: 'profile_image',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


export const HomePageScalarFieldEnum = {
  id: 'id',
  isActive: 'isActive',
  about_us_years_exp: 'about_us_years_exp',
  about_us_products: 'about_us_products',
  about_us_countries: 'about_us_countries',
  about_us_brands: 'about_us_brands',
  contact_email: 'contact_email',
  contact_phone: 'contact_phone',
  contact_link_map: 'contact_link_map',
  contact_address: 'contact_address',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type HomePageScalarFieldEnum = (typeof HomePageScalarFieldEnum)[keyof typeof HomePageScalarFieldEnum]


export const HomePageIdScalarFieldEnum = {
  id: 'id',
  about_us_badge: 'about_us_badge',
  about_us_title: 'about_us_title',
  about_us_desc: 'about_us_desc',
  services_badge: 'services_badge',
  services_title: 'services_title',
  services_desc: 'services_desc',
  news_badge: 'news_badge',
  news_title: 'news_title',
  news_desc: 'news_desc',
  partners_badge: 'partners_badge',
  partners_title: 'partners_title',
  partners_desc: 'partners_desc',
  contact_title: 'contact_title',
  contact_desc: 'contact_desc',
  homePageId: 'homePageId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type HomePageIdScalarFieldEnum = (typeof HomePageIdScalarFieldEnum)[keyof typeof HomePageIdScalarFieldEnum]


export const HomePageEnScalarFieldEnum = {
  id: 'id',
  about_us_badge: 'about_us_badge',
  about_us_title: 'about_us_title',
  about_us_desc: 'about_us_desc',
  services_badge: 'services_badge',
  services_title: 'services_title',
  services_desc: 'services_desc',
  news_badge: 'news_badge',
  news_title: 'news_title',
  news_desc: 'news_desc',
  partners_badge: 'partners_badge',
  partners_title: 'partners_title',
  partners_desc: 'partners_desc',
  contact_title: 'contact_title',
  contact_desc: 'contact_desc',
  homePageId: 'homePageId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type HomePageEnScalarFieldEnum = (typeof HomePageEnScalarFieldEnum)[keyof typeof HomePageEnScalarFieldEnum]


export const HeroSlideScalarFieldEnum = {
  id: 'id',
  order: 'order',
  bg_image: 'bg_image',
  title_id: 'title_id',
  desc_id: 'desc_id',
  title_en: 'title_en',
  desc_en: 'desc_en',
  homePageId: 'homePageId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type HeroSlideScalarFieldEnum = (typeof HeroSlideScalarFieldEnum)[keyof typeof HeroSlideScalarFieldEnum]


export const AboutUsPageScalarFieldEnum = {
  id: 'id',
  isActive: 'isActive',
  hero_bg: 'hero_bg',
  vision_image_parent: 'vision_image_parent',
  vision_image_child: 'vision_image_child',
  mission_image_parent: 'mission_image_parent',
  mission_image_child: 'mission_image_child',
  history_image_parent: 'history_image_parent',
  history_image_child: 'history_image_child',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AboutUsPageScalarFieldEnum = (typeof AboutUsPageScalarFieldEnum)[keyof typeof AboutUsPageScalarFieldEnum]


export const AboutUsPageIdScalarFieldEnum = {
  id: 'id',
  hero_badge: 'hero_badge',
  hero_title: 'hero_title',
  hero_desc: 'hero_desc',
  vision_badge: 'vision_badge',
  vision_title: 'vision_title',
  vision_desc: 'vision_desc',
  vision_quote: 'vision_quote',
  vision_list: 'vision_list',
  mission_badge: 'mission_badge',
  mission_title: 'mission_title',
  mission_desc: 'mission_desc',
  mission_quote: 'mission_quote',
  mission_list: 'mission_list',
  history_badge: 'history_badge',
  history_title: 'history_title',
  history_desc: 'history_desc',
  company_structure_badge: 'company_structure_badge',
  company_structure_title: 'company_structure_title',
  company_structure_desc: 'company_structure_desc',
  boc_badge: 'boc_badge',
  boc_title: 'boc_title',
  boc_desc: 'boc_desc',
  bod_badge: 'bod_badge',
  bod_title: 'bod_title',
  bod_desc: 'bod_desc',
  aboutUsPageId: 'aboutUsPageId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AboutUsPageIdScalarFieldEnum = (typeof AboutUsPageIdScalarFieldEnum)[keyof typeof AboutUsPageIdScalarFieldEnum]


export const AboutUsPageEnScalarFieldEnum = {
  id: 'id',
  hero_badge: 'hero_badge',
  hero_title: 'hero_title',
  hero_desc: 'hero_desc',
  vision_badge: 'vision_badge',
  vision_title: 'vision_title',
  vision_desc: 'vision_desc',
  vision_quote: 'vision_quote',
  vision_list: 'vision_list',
  mission_badge: 'mission_badge',
  mission_title: 'mission_title',
  mission_desc: 'mission_desc',
  mission_quote: 'mission_quote',
  mission_list: 'mission_list',
  history_badge: 'history_badge',
  history_title: 'history_title',
  history_desc: 'history_desc',
  company_structure_badge: 'company_structure_badge',
  company_structure_title: 'company_structure_title',
  company_structure_desc: 'company_structure_desc',
  boc_badge: 'boc_badge',
  boc_title: 'boc_title',
  boc_desc: 'boc_desc',
  bod_badge: 'bod_badge',
  bod_title: 'bod_title',
  bod_desc: 'bod_desc',
  aboutUsPageId: 'aboutUsPageId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AboutUsPageEnScalarFieldEnum = (typeof AboutUsPageEnScalarFieldEnum)[keyof typeof AboutUsPageEnScalarFieldEnum]


export const GovernanceScalarFieldEnum = {
  id: 'id',
  name: 'name',
  position: 'position',
  position_desc: 'position_desc',
  photo_image: 'photo_image',
  aboutUsPageId: 'aboutUsPageId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type GovernanceScalarFieldEnum = (typeof GovernanceScalarFieldEnum)[keyof typeof GovernanceScalarFieldEnum]


export const CompanyStructureScalarFieldEnum = {
  id: 'id',
  name: 'name',
  icon_image: 'icon_image',
  aboutUsPageId: 'aboutUsPageId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CompanyStructureScalarFieldEnum = (typeof CompanyStructureScalarFieldEnum)[keyof typeof CompanyStructureScalarFieldEnum]


export const NewsPageScalarFieldEnum = {
  id: 'id',
  isActive: 'isActive',
  hero_bg: 'hero_bg',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type NewsPageScalarFieldEnum = (typeof NewsPageScalarFieldEnum)[keyof typeof NewsPageScalarFieldEnum]


export const NewsPageEnScalarFieldEnum = {
  id: 'id',
  hero_badge: 'hero_badge',
  hero_title: 'hero_title',
  hero_desc: 'hero_desc',
  news_badge: 'news_badge',
  news_title: 'news_title',
  news_desc: 'news_desc',
  csr_badge: 'csr_badge',
  csr_title: 'csr_title',
  csr_desc: 'csr_desc',
  newsPageId: 'newsPageId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type NewsPageEnScalarFieldEnum = (typeof NewsPageEnScalarFieldEnum)[keyof typeof NewsPageEnScalarFieldEnum]


export const NewsPageIdScalarFieldEnum = {
  id: 'id',
  hero_badge: 'hero_badge',
  hero_title: 'hero_title',
  hero_desc: 'hero_desc',
  news_badge: 'news_badge',
  news_title: 'news_title',
  news_desc: 'news_desc',
  csr_badge: 'csr_badge',
  csr_title: 'csr_title',
  csr_desc: 'csr_desc',
  newsPageId: 'newsPageId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type NewsPageIdScalarFieldEnum = (typeof NewsPageIdScalarFieldEnum)[keyof typeof NewsPageIdScalarFieldEnum]


export const ServicePageScalarFieldEnum = {
  id: 'id',
  hero_bg: 'hero_bg',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ServicePageScalarFieldEnum = (typeof ServicePageScalarFieldEnum)[keyof typeof ServicePageScalarFieldEnum]


export const ServicePageIdScalarFieldEnum = {
  id: 'id',
  hero_badge: 'hero_badge',
  hero_title: 'hero_title',
  hero_desc: 'hero_desc',
  used_car_gallery_badge: 'used_car_gallery_badge',
  used_car_gallery_title: 'used_car_gallery_title',
  used_car_gallery_desc: 'used_car_gallery_desc',
  servicePageId: 'servicePageId'
} as const

export type ServicePageIdScalarFieldEnum = (typeof ServicePageIdScalarFieldEnum)[keyof typeof ServicePageIdScalarFieldEnum]


export const ServicePageEnScalarFieldEnum = {
  id: 'id',
  hero_badge: 'hero_badge',
  hero_title: 'hero_title',
  hero_desc: 'hero_desc',
  used_car_gallery_badge: 'used_car_gallery_badge',
  used_car_gallery_title: 'used_car_gallery_title',
  used_car_gallery_desc: 'used_car_gallery_desc',
  servicePageId: 'servicePageId'
} as const

export type ServicePageEnScalarFieldEnum = (typeof ServicePageEnScalarFieldEnum)[keyof typeof ServicePageEnScalarFieldEnum]


export const ServiceScalarFieldEnum = {
  id: 'id',
  bg_image: 'bg_image',
  isActive: 'isActive',
  order: 'order',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


export const ServiceIdScalarFieldEnum = {
  id: 'id',
  badge: 'badge',
  title: 'title',
  desc: 'desc',
  desc_sort: 'desc_sort',
  location: 'location',
  contact: 'contact',
  email: 'email',
  quote: 'quote',
  serviceId: 'serviceId'
} as const

export type ServiceIdScalarFieldEnum = (typeof ServiceIdScalarFieldEnum)[keyof typeof ServiceIdScalarFieldEnum]


export const ServiceEnScalarFieldEnum = {
  id: 'id',
  badge: 'badge',
  title: 'title',
  desc: 'desc',
  desc_sort: 'desc_sort',
  location: 'location',
  contact: 'contact',
  email: 'email',
  quote: 'quote',
  serviceId: 'serviceId'
} as const

export type ServiceEnScalarFieldEnum = (typeof ServiceEnScalarFieldEnum)[keyof typeof ServiceEnScalarFieldEnum]


export const CarGalleryScalarFieldEnum = {
  id: 'id',
  car_image: 'car_image',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CarGalleryScalarFieldEnum = (typeof CarGalleryScalarFieldEnum)[keyof typeof CarGalleryScalarFieldEnum]


export const CarGalleryIdScalarFieldEnum = {
  id: 'id',
  title: 'title',
  desc: 'desc',
  carGalleryId: 'carGalleryId'
} as const

export type CarGalleryIdScalarFieldEnum = (typeof CarGalleryIdScalarFieldEnum)[keyof typeof CarGalleryIdScalarFieldEnum]


export const CarGalleryEnScalarFieldEnum = {
  id: 'id',
  title: 'title',
  desc: 'desc',
  carGalleryId: 'carGalleryId'
} as const

export type CarGalleryEnScalarFieldEnum = (typeof CarGalleryEnScalarFieldEnum)[keyof typeof CarGalleryEnScalarFieldEnum]


export const PartnerScalarFieldEnum = {
  id: 'id',
  name: 'name',
  logo_image: 'logo_image',
  category: 'category',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PartnerScalarFieldEnum = (typeof PartnerScalarFieldEnum)[keyof typeof PartnerScalarFieldEnum]


export const NewsNewsScalarFieldEnum = {
  id: 'id',
  isPublished: 'isPublished',
  image: 'image',
  author: 'author',
  author_image: 'author_image',
  publishedAt: 'publishedAt',
  report_id: 'report_id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type NewsNewsScalarFieldEnum = (typeof NewsNewsScalarFieldEnum)[keyof typeof NewsNewsScalarFieldEnum]


export const NewsNewsIdScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  content: 'content',
  newsNewsId: 'newsNewsId'
} as const

export type NewsNewsIdScalarFieldEnum = (typeof NewsNewsIdScalarFieldEnum)[keyof typeof NewsNewsIdScalarFieldEnum]


export const NewsNewsEnScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  content: 'content',
  newsNewsId: 'newsNewsId'
} as const

export type NewsNewsEnScalarFieldEnum = (typeof NewsNewsEnScalarFieldEnum)[keyof typeof NewsNewsEnScalarFieldEnum]


export const NewsCSRScalarFieldEnum = {
  id: 'id',
  isPublished: 'isPublished',
  author: 'author',
  author_image: 'author_image',
  publishedAt: 'publishedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type NewsCSRScalarFieldEnum = (typeof NewsCSRScalarFieldEnum)[keyof typeof NewsCSRScalarFieldEnum]


export const NewsCSRImageScalarFieldEnum = {
  id: 'id',
  image: 'image',
  description_en: 'description_en',
  description_id: 'description_id',
  newsCSRId: 'newsCSRId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type NewsCSRImageScalarFieldEnum = (typeof NewsCSRImageScalarFieldEnum)[keyof typeof NewsCSRImageScalarFieldEnum]


export const NewsCSRIdScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  content: 'content',
  newsCSRId: 'newsCSRId'
} as const

export type NewsCSRIdScalarFieldEnum = (typeof NewsCSRIdScalarFieldEnum)[keyof typeof NewsCSRIdScalarFieldEnum]


export const NewsCSREnScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  content: 'content',
  newsCSRId: 'newsCSRId'
} as const

export type NewsCSREnScalarFieldEnum = (typeof NewsCSREnScalarFieldEnum)[keyof typeof NewsCSREnScalarFieldEnum]


export const InvestorPageScalarFieldEnum = {
  id: 'id',
  isActive: 'isActive',
  hero_bg: 'hero_bg',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type InvestorPageScalarFieldEnum = (typeof InvestorPageScalarFieldEnum)[keyof typeof InvestorPageScalarFieldEnum]


export const InvestorPageIdScalarFieldEnum = {
  id: 'id',
  hero_badge: 'hero_badge',
  hero_title: 'hero_title',
  hero_desc: 'hero_desc',
  stakeholders_badge: 'stakeholders_badge',
  stakeholders_title: 'stakeholders_title',
  stakeholders_desc: 'stakeholders_desc',
  report_badge: 'report_badge',
  report_title: 'report_title',
  report_desc: 'report_desc',
  investorPageId: 'investorPageId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type InvestorPageIdScalarFieldEnum = (typeof InvestorPageIdScalarFieldEnum)[keyof typeof InvestorPageIdScalarFieldEnum]


export const InvestorPageEnScalarFieldEnum = {
  id: 'id',
  hero_badge: 'hero_badge',
  hero_title: 'hero_title',
  hero_desc: 'hero_desc',
  stakeholders_badge: 'stakeholders_badge',
  stakeholders_title: 'stakeholders_title',
  stakeholders_desc: 'stakeholders_desc',
  report_badge: 'report_badge',
  report_title: 'report_title',
  report_desc: 'report_desc',
  investorPageId: 'investorPageId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type InvestorPageEnScalarFieldEnum = (typeof InvestorPageEnScalarFieldEnum)[keyof typeof InvestorPageEnScalarFieldEnum]


export const SharesScalarFieldEnum = {
  id: 'id',
  category: 'category',
  value: 'value',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SharesScalarFieldEnum = (typeof SharesScalarFieldEnum)[keyof typeof SharesScalarFieldEnum]


export const ReportScalarFieldEnum = {
  id: 'id',
  title_id: 'title_id',
  title_en: 'title_en',
  description_id: 'description_id',
  description_en: 'description_en',
  file_url: 'file_url',
  publish_at: 'publish_at',
  is_publish: 'is_publish',
  reportCategoryId: 'reportCategoryId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


export const ReportCategoryScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description'
} as const

export type ReportCategoryScalarFieldEnum = (typeof ReportCategoryScalarFieldEnum)[keyof typeof ReportCategoryScalarFieldEnum]


export const MetadataScalarFieldEnum = {
  id: 'id',
  destination: 'destination',
  title_id: 'title_id',
  title_en: 'title_en',
  description_id: 'description_id',
  description_en: 'description_en',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type MetadataScalarFieldEnum = (typeof MetadataScalarFieldEnum)[keyof typeof MetadataScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'Role'
 */
export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


/**
 * Reference to a field of type 'Role[]'
 */
export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'Position'
 */
export type EnumPositionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Position'>
    


/**
 * Reference to a field of type 'Position[]'
 */
export type ListEnumPositionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Position[]'>
    


/**
 * Reference to a field of type 'PartnerCategory'
 */
export type EnumPartnerCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PartnerCategory'>
    


/**
 * Reference to a field of type 'PartnerCategory[]'
 */
export type ListEnumPartnerCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PartnerCategory[]'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[]
}
export type GlobalOmitConfig = {
  user?: Prisma.UserOmit
  homePage?: Prisma.HomePageOmit
  homePageId?: Prisma.HomePageIdOmit
  homePageEn?: Prisma.HomePageEnOmit
  heroSlide?: Prisma.HeroSlideOmit
  aboutUsPage?: Prisma.AboutUsPageOmit
  aboutUsPageId?: Prisma.AboutUsPageIdOmit
  aboutUsPageEn?: Prisma.AboutUsPageEnOmit
  governance?: Prisma.GovernanceOmit
  companyStructure?: Prisma.CompanyStructureOmit
  newsPage?: Prisma.NewsPageOmit
  newsPageEn?: Prisma.NewsPageEnOmit
  newsPageId?: Prisma.NewsPageIdOmit
  servicePage?: Prisma.ServicePageOmit
  servicePageId?: Prisma.ServicePageIdOmit
  servicePageEn?: Prisma.ServicePageEnOmit
  service?: Prisma.ServiceOmit
  serviceId?: Prisma.ServiceIdOmit
  serviceEn?: Prisma.ServiceEnOmit
  carGallery?: Prisma.CarGalleryOmit
  carGalleryId?: Prisma.CarGalleryIdOmit
  carGalleryEn?: Prisma.CarGalleryEnOmit
  partner?: Prisma.PartnerOmit
  newsNews?: Prisma.NewsNewsOmit
  newsNewsId?: Prisma.NewsNewsIdOmit
  newsNewsEn?: Prisma.NewsNewsEnOmit
  newsCSR?: Prisma.NewsCSROmit
  newsCSRImage?: Prisma.NewsCSRImageOmit
  newsCSRId?: Prisma.NewsCSRIdOmit
  newsCSREn?: Prisma.NewsCSREnOmit
  investorPage?: Prisma.InvestorPageOmit
  investorPageId?: Prisma.InvestorPageIdOmit
  investorPageEn?: Prisma.InvestorPageEnOmit
  shares?: Prisma.SharesOmit
  report?: Prisma.ReportOmit
  reportCategory?: Prisma.ReportCategoryOmit
  metadata?: Prisma.MetadataOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

